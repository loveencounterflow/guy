{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/src.coffee"
  ],
  "names": [],
  "mappings": "AAkHY;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA",
  "sourcesContent": [
    "\n# 'use strict'\n\n# # @PARSER                   = require 'acorn-loose'\n# @STRICT_PARSER            = require 'acorn'\n# @LOOSE_PARSER             = require 'acorn-loose'\n# @AST_walk                 = require 'acorn-walk'\n# @ASTRING                  = require 'astring'\n# H                         = require './_helpers'\n# misfit                    = Symbol 'misfit'\n\n\n# #-----------------------------------------------------------------------------------------------------------\n# H.types.declare 'guy_src_parse_use', tests:\n#   \"x in [ 'strict', 'loose', 'strict,loose', ]\": ( x ) -> x in [ 'strict', 'loose', 'strict,loose', ]\n\n# #-----------------------------------------------------------------------------------------------------------\n# H.types.declare 'guy_src_parse_cfg', tests:\n#   \"@isa.object x\":                          ( x ) -> @isa.object x\n#   \"@isa_optional.text x.text\":              ( x ) -> @isa_optional.text x.text\n#   \"@isa.guy_src_parse_use x.use\":           ( x ) -> @isa.guy_src_parse_use x.use\n#   \"@isa_optional.callable x.function\":      ( x ) -> @isa_optional.callable x.function\n#   \"must have either x.text or x.function\":  ( x ) ->\n#     return ( x.text? and not x.function? ) or ( x.function? and not x.text? )\n# H.types.defaults.guy_src_parse_cfg =\n#   text:         null\n#   function:     null\n#   fallback:     misfit\n#   use:          'strict,loose'\n\n# #-----------------------------------------------------------------------------------------------------------\n# H.types.defaults.guy_src_acorn_cfg =\n#   ecmaVersion:                  'latest'\n#   # # sourceType:                   'script'\n#   # onInsertedSemicolon:          undefined\n#   # onTrailingComma:              undefined\n#   # allowReserved:                undefined\n#   # allowReturnOutsideFunction:   undefined\n#   # allowImportExportEverywhere:  undefined\n#   # allowAwaitOutsideFunction:    undefined\n#   # allowSuperOutsideMethod:      undefined\n#   # allowHashBang:                undefined\n#   # locations:                    undefined\n#   # onToken:                      undefined\n#   # onComment:                    undefined\n#   # ranges:                       undefined\n#   # program:                      undefined\n#   # sourceFile:                   undefined\n#   # directSourceFile:             undefined\n#   # preserveParens:               undefined\n\n# #-----------------------------------------------------------------------------------------------------------\n# @parse = ( cfg ) =>\n#   H.types.validate.guy_src_parse_cfg cfg = { H.types.defaults.guy_src_parse_cfg..., cfg..., }\n#   return @_parse cfg\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_parse = ( cfg ) =>\n#   text            = if cfg.function? then cfg.function.toString() else cfg.text\n#   text            = text.replace /\\s*\\n\\s*/g, ' '\n#   { use\n#     fallback  }   = cfg\n#   acorn_cfg       = { H.types.defaults.guy_src_acorn_cfg..., }\n#   acorn_cfg[ k ]  = cfg[ k ] for k of cfg unless k in H.types.defaults.guy_src_parse_cfg\n#   try\n#     switch use\n#       when 'strict'       then return @STRICT_PARSER.parse  text, acorn_cfg\n#       when 'loose'        then return @LOOSE_PARSER.parse   text, acorn_cfg\n#       when 'strict,loose'\n#         try return @STRICT_PARSER.parse text, acorn_cfg catch _\n#         return @LOOSE_PARSER.parse text, acorn_cfg\n#   catch error\n#     throw error if fallback is misfit\n#   return fallback\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_generate = ( P... ) => @ASTRING.generate P...\n\n# #-----------------------------------------------------------------------------------------------------------\n# @slug_node_from_simple_function = ( cfg ) =>\n#   H.types.validate.guy_src_parse_cfg cfg = { H.types.defaults.guy_src_parse_cfg..., cfg..., }\n#   return @_slug_node_from_simple_function cfg\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_slug_node_from_simple_function = ( cfg ) =>\n#   collector =\n#     rtn:    []\n#     blk:    []\n#   ast       = @_parse cfg\n#   return cfg.fallback if ( ast isnt misfit ) and ( ast is cfg.fallback )\n#   @AST_walk.simple ast,\n#     ReturnStatement:      ( node ) -> collector.rtn.push node\n#     BlockStatement:       ( node ) -> collector.blk.push node\n#   R = null\n#   return collector.rtn.at 0   if collector.rtn.length is 1\n#   return collector.blk.at -1  if collector.blk.length >  0\n#   return ast\n\n# #-----------------------------------------------------------------------------------------------------------\n# @slug_from_simple_function = ( cfg ) =>\n#   H.types.validate.guy_src_parse_cfg cfg = { H.types.defaults.guy_src_parse_cfg..., cfg..., }\n#   ast = @_slug_node_from_simple_function cfg\n#   return cfg.fallback if ( ast isnt misfit ) and ( ast is cfg.fallback )\n#   R = @_generate ast\n#   R = R.trim().replace /\\s*\\n\\s*/g, ' '\n#   if R is '{ [native, code]; }'\n#     return cfg.fallback unless cfg.fallback is misfit\n#     throw new Error \"^guy.src.slug_node_from_simple_function@1^ unable to parse native code\"\n#   switch ast.type\n#     when 'ReturnStatement'\n#       R = R.replace /^return\\s*/, ''\n#       R = R.replace /;$/, ''\n#     when 'BlockStatement'\n#       R = R.replace /^\\{\\s*(.*?)\\s*\\}$/, '$1'\n#   return R\n\n\n\n"
  ]
}