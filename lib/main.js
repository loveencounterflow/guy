// Generated by CoffeeScript 1.8.0
(function() {
  var ASYNC, TEXT, TRM, alert, badge, debug, docopt, echo, gitteh, glob, help, info, log, njs_path, njs_url, rainbow, request, rpr, urge, warn, whisper;

  njs_path = require('path');

  njs_url = require('url');

  TEXT = require('coffeenode-text');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'guy';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  glob = require('glob');


  /* https://github.com/mikeal/request */

  request = require('request');


  /* https://github.com/caolan/async */

  ASYNC = require('async');


  /* https://github.com/libgit2/node-gitteh */

  gitteh = require('gitteh');


  /* http://docopt.org
      https://github.com/docopt/docopt
   */

  docopt = (require('docopt')).docopt;

  this.raw_options = null;

  this.options = {};

  this.commands = {};

  this.commands['watch'] = function() {
    throw new Error("not implemented");
  };

  this.commands['repl'] = function() {
    var get_repl_completer, options, project_names, readline;
    get_repl_completer = function(completions) {
      return (function(_this) {
        return function(line) {
          var hits;
          hits = completions.filter(function(completion) {
            return (completion.indexOf(line)) === 0;
          });
          return [(hits.length ? hits : completions), line];
        };
      })(this);
    };
    project_names = this._get_project_names();
    options = {
      input: process.stdin,
      output: process.stdout,

      /* TAINT synchronize usage message and tab completion */
      completer: get_repl_completer("help build pub github npm watch".split(/\s+/))
    };
    readline = (require('readline')).createInterface(options);
    readline.question("Enter a command:", (function(_this) {
      return function(answer) {
        info("Thank you for your valuable feedback: ", rpr(answer));
        readline.close();

        /* YUCK */
        options['completer'] = get_repl_completer(project_names);
        readline = (require('readline')).createInterface(options);
        return readline.question("Enter an optional project name:", function(answer) {
          info("Thank you for your valuable feedback: ", rpr(answer));
          return readline.close();
        });
      };
    })(this));
    return null;
  };

  this.get_project_candidate_routes = function() {

    /* Returns a list of all locators of all subfolders of the current working directory (`process.cwd()`).
    This may include locators to directories that are not `require`able NodeJS / npm packages.
     */
    var home, route, routes;
    home = process.cwd();
    routes = (function() {
      var _i, _len, _ref, _results;
      _ref = glob.sync('./*/');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        _results.push(route.replace(/.$/, ''));
      }
      return _results;
    })();
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = routes.length; _i < _len; _i++) {
        route = routes[_i];
        _results.push(njs_path.join(home, route));
      }
      return _results;
    })();
  };

  this.is_requirable = function(route) {
    var error;
    try {
      require.resolve(route);
      return true;
    } catch (_error) {
      error = _error;
      if (error.code !== 'MODULE_NOT_FOUND') {
        throw error;
      }
      return false;
    }
  };

  this.get_package_json = function(route) {
    var error;
    route = njs_path.join(route, 'package.json');
    try {
      return require(route);
    } catch (_error) {
      error = _error;
      if (error.code !== 'MODULE_NOT_FOUND') {
        throw error;
      }
      return null;
    }
  };

  this.read_npm_info = function(name, handler) {
    var options;
    options = {
      'url': njs_url.resolve('https://registry.npmjs.org', name),
      'json': true
    };
    request(options, (function(_this) {
      return function(error, response, npm_info) {
        var message;
        if (error != null) {
          return handler(error);
        }
        if ((message = npm_info['error']) != null) {
          if (message === 'not_found') {
            return handler(null, null);
          }
          return handler(new Error(message));
        }
        return handler(null, npm_info);
      };
    })(this));
    return null;
  };

  this.read_git_infos = function(route, handler) {
    var Z, open_repo, read_remote;
    Z = {
      'route': route,
      'is-git': null,
      'remote-url': null
    };
    open_repo = (function(_this) {
      return function(handler) {
        gitteh.openRepository(route, function(error, repo) {
          var accept;
          if (error != null) {
            accept = false;
            accept = accept || /The `\.git` file at .+ is malformed/.test(error['message']);
            accept = accept || /Could not find repository/.test(error['message']);
            if (!accept) {
              return handler(error);
            }
            Z['is-git'] = false;
            return handler(null, null);
          }
          Z['is-git'] = true;
          return handler(null, repo);
        });
        return null;
      };
    })(this);
    read_remote = (function(_this) {
      return function(repo, handler) {
        if (repo == null) {
          return handler(null, null);
        }
        repo.remote('origin', function(error, remote) {
          var accept;
          if (error != null) {
            accept = false;
            accept = accept || /Config variable 'remote\.origin\.url' not found/.test(error['message']);
            if (!accept) {
              return handler(error);
            }
            return handler(null, null);
          }
          Z['remote-url'] = remote['url'];
          return handler(null, remote);
        });
        return null;
      };
    })(this);
    ASYNC.waterfall([open_repo, read_remote], (function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this.read_project_infos = function(handler) {
    var route, routes, tasks, _fn, _i, _len;
    routes = this.get_project_candidate_routes();
    tasks = [];
    _fn = (function(_this) {
      return function(route) {
        var package_info, project_info, _ref, _ref1;
        package_info = _this.get_package_json(route);
        project_info = {
          'route': route,
          'fs-name': njs_path.basename(route),
          'has-package-json': package_info != null,
          'npm-name': (_ref = package_info != null ? package_info['name'] : void 0) != null ? _ref : null,
          'local-version': (_ref1 = package_info != null ? package_info['version'] : void 0) != null ? _ref1 : null,
          'is-requirable': _this.is_requirable(route),
          'is-git': null,
          'remote-url': null,
          'has-changes': null,
          'is-on-npm': null,
          'npm-version': null
        };
        return tasks.push(function(handler) {
          return _this.read_git_infos(route, function(error, git_info) {
            if (error != null) {
              return handler(error);
            }
            project_info['is-git'] = git_info['is-git'];
            project_info['remote-url'] = git_info['remote-url'];
            return handler(null, project_info);
          });
        });
      };
    })(this);
    for (_i = 0, _len = routes.length; _i < _len; _i++) {
      route = routes[_i];
      _fn(route);
    }
    ASYNC.parallelLimit(tasks, 10, handler);
    return null;
  };

  this.read_npm_info('coffeenode-text', function(error, npm_info) {
    var _ref, _ref1;
    if (error != null) {
      throw error;
    }
    if (npm_info === null) {
      return whisper('not found');
    } else {
      urge('npm version:', (_ref = (_ref1 = npm_info['dist-tags']) != null ? _ref1['latest'] : void 0) != null ? _ref : null);
      debug(1 * new Date());
      debug(new Date(1402427194639));
      debug(new Date(1406068890198));
      debug(new Date('2014-07-22'));
      return debug(1 * new Date('2014-07-22'));
    }
  });

  (function() {
    var command, name, usage, _ref;
    if (module.parent == null) {
      usage = "\nUsage:\n  guy                           Start interactive session.\n  guy [<command>] [<name>]\n  guy foo [<name>]\n  guy help [<command>]          Show help.\n  guy build [<name>]            Build project.\n  guy pub [<name>]              Same as `guy build && guy github && guy npm`.\n  guy github [<name>]           Build and publish changes to github.com.\n  guy npm [<name>]              Build and publish changes to npmjs.org.\n  guy watch [<name>]\n  guy ls [<name>]               List one or all projects with build and publishing status.\n\nOptions:\n  -h, --help                    Show help.\n  -v, --version                 Show version.";
      this.raw_options = docopt(usage, {
        version: (require('../package.json'))['version']
      });
      this.options['command-name'] = command = (_ref = this.raw_options['<command>']) != null ? _ref : 'repl';
      this.options['project-name'] = name = this.raw_options['<name>'];
      debug(this.raw_options);
      info(this.options);
      command = this.commands[command];
      if (command == null) {
        throw new Error("unknown command " + (rpr(command)));
      }
      return (command.bind(this))();
    }
  });

}).call(this);
