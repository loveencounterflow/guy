// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, FS, PATH, SEMVER, _request, alert, badge, debug, echo, help, info, log, moment, rpr, step, urge, warn, whisper, σ_module_path,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'GUY';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  _request = require('request');

  step = require('coffeenode-suspend').step;

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  require('pipedreams/lib/plugin-tabulate');

  moment = require('moment');

  SEMVER = require('semver');

  σ_module_path = Symbol["for"]('module-path');

  this._request = function(url, handler) {
    _request(url, (function(_this) {
      return function(error, response, body) {
        var status;
        if (error != null) {
          return handler(error);
        }
        switch (status = response.statusCode) {
          case 404:
            return handler(null, {});
          case 200:
            return handler(null, JSON.parse(body));
          default:
            return handler(new Error(url + "\n" + status + " -- " + response.statusMessage));
        }
      };
    })(this));
    return null;
  };

  this._new_state = function(settings) {

    /* TAINT use multimix for options handling */
    return Object.assign({}, require('../options'));
  };

  this._find_max_semvers = function(semvers) {

    /* choose whether you want all max major versions */
    var i, is_semver, is_v0, len, max_all_semver, max_v0_semver, semver, v0_matcher;
    max_all_semver = null;
    max_v0_semver = null;
    v0_matcher = '>=0.0.0 <1.0.0';
    is_semver = function(x) {
      return (SEMVER.valid(x)) != null;
    };
    is_v0 = function(semver) {
      return SEMVER.satisfies(semver, v0_matcher);
    };
    for (i = 0, len = semvers.length; i < len; i++) {
      semver = semvers[i];
      if (!is_semver(semver)) {
        continue;
      }
      if (max_all_semver != null) {
        if (SEMVER.gt(semver, max_all_semver)) {
          max_all_semver = semver;
        }
      } else {
        max_all_semver = semver;
      }
      if (is_v0(semver)) {
        if (max_v0_semver != null) {
          if (SEMVER.gt(semver, max_v0_semver)) {
            max_v0_semver = semver;
          }
        } else {
          max_v0_semver = semver;
        }
      }
    }
    return [max_v0_semver, max_all_semver];
  };

  this.$read_package_json = function(S) {
    return $((function(_this) {
      return function(package_path, send) {
        var package_json;
        package_json = require(PATH.resolve(package_path, 'package.json'));
        package_json[σ_module_path] = package_path;
        return send(package_json);
      };
    })(this));
  };

  this.$compile_pkgnfo = function(S) {

    /* `pkgnfo`: package info object */
    return $((function(_this) {
      return function(package_json, send) {
        var dependency_name, pkgnfo, ref, semver_term;
        pkgnfo = {};
        pkgnfo['path'] = package_json[σ_module_path];
        pkgnfo['name'] = package_json['name'];
        pkgnfo['local'] = {
          version: package_json['version']
        };
        pkgnfo['dependencies'] = package_json['dependencies'];
        if (package_json['devDependencies'] != null) {
          ref = package_json['devDependencies'];
          for (dependency_name in ref) {
            semver_term = ref[dependency_name];
            pkgnfo['dependencies'][dependency_name] = semver_term;
          }
        }
        return send(pkgnfo);
      };
    })(this));
  };

  this.$read_npm = function(S) {
    return $async((function(_this) {
      return function(pkgnfo, send, end) {
        var date_by_versions, package_name, url;
        if (pkgnfo != null) {
          pkgnfo['npm'] = {};
          pkgnfo['npm']['date-by-versions'] = date_by_versions = {};
          package_name = pkgnfo['name'];
          url = "http://registry.npmjs.org/" + package_name;
          step(function*(resume) {
            var date_txt, npm_info, npm_version, ref;
            npm_info = (yield _this._request(url, resume));
            if (npm_info['time'] != null) {
              ref = npm_info['time'];
              for (npm_version in ref) {
                date_txt = ref[npm_version];

                /* choose local or universal time */
                date_by_versions[npm_version] = moment(date_txt);
              }
            }
            send.done(pkgnfo);
            return null;
          });
        }
        if (end != null) {
          end();
        }
        return null;
      };
    })(this));
  };

  this.$identify_interesting_versions = function(S) {
    return $((function(_this) {
      return function(pkgnfo) {
        var i, len, ref, target, version;
        pkgnfo['interesting-versions'] = target = [];
        target.push('created');
        target.push('modified');
        ref = _this._find_max_semvers(Object.keys(pkgnfo['npm']['date-by-versions']));
        for (i = 0, len = ref.length; i < len; i++) {
          version = ref[i];
          target.push(version);
        }
        return null;
      };
    })(this));
  };

  this.$as_table = function(S) {
    var $cast, $colorize, $show, table_settings;
    table_settings = {
      headings: ['name', 'local', 'npm', 'date'],
      alignment: 'left',
      widths: [30, 12, 12, 25]
    };
    $cast = (function(_this) {
      return function() {
        return $(function(pkgnfo, send) {
          var date, date_by_versions, date_txt, local_version, name, name_display, npm_version, ref, results, version;
          local_version = pkgnfo['local']['version'];
          date_by_versions = pkgnfo['npm']['date-by-versions'];
          name_display = pkgnfo['name'];
          for (npm_version in date_by_versions) {
            date = date_by_versions[npm_version];
            if (indexOf.call(pkgnfo['interesting-versions'], npm_version) < 0) {
              continue;
            }

            /* choose time format */
            date_txt = (date.format('YYYY MM DD')) + (" (" + (date.fromNow()) + ")");
            if (local_version === npm_version) {
              send([name_display, local_version, npm_version, date_txt]);
            } else {
              send([name_display, '— ··· —', npm_version, date_txt]);
            }
            name_display = '  — ··· —';
          }
          send([pkgnfo['name'], local_version, '-/-', '-/-']);
          ref = pkgnfo['dependencies'];
          results = [];
          for (name in ref) {
            version = ref[name];

            /* TAINT */
            results.push(send([name, version, '', 'N/A']));
          }
          return results;
        });
      };
    })(this);
    $colorize = (function(_this) {
      return function() {
        return $(function(row, send) {
          return send(row);
        });
      };
    })(this);
    $show = (function(_this) {
      return function() {
        return $(function(row) {
          return echo(row);
        });
      };
    })(this);
    return D.new_stream({
      pipeline: [$cast(), $colorize(), D.$tabulate(table_settings), $show()]
    });
  };

  this.f = function(handler) {
    var S, i, input, len, package_locator, package_path, package_paths;
    S = this._new_state();
    input = D.new_stream();
    input.pipe(this.$read_package_json(S)).pipe(this.$compile_pkgnfo(S)).pipe(this.$read_npm(S)).pipe(this.$identify_interesting_versions(S)).pipe(this.$as_table(S)).pipe($('finish', function() {
      return handler();
    }));
    package_paths = ['cnd', 'kleinbild'];
    for (i = 0, len = package_paths.length; i < len; i++) {
      package_path = package_paths[i];
      package_locator = PATH.resolve(__dirname, '../..', package_path);
      D.send(input, package_locator);
    }
    D.end(input);
    return null;
  };

}).call(this);

//# sourceMappingURL=main.js.map
