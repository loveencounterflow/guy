// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, FS, PATH, _request, alert, badge, debug, echo, help, info, log, rpr, step, urge, warn, whisper, σ_module_path;

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'GUY';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  _request = require('request');

  step = require('coffeenode-suspend').step;

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  require('pipedreams/lib/plugin-tabulate');

  σ_module_path = Symbol["for"]('module-path');

  this._request = function(url, handler) {
    _request(url, (function(_this) {
      return function(error, response, body) {
        var status;
        if (error != null) {
          return handler(error);
        }
        if ((status = response.statusCode) !== 200) {
          return handler(new Error(url + "\n" + status + " -- " + response.statusMessage));
        }
        return handler(null, JSON.parse(body));
      };
    })(this));
    return null;
  };

  this._new_state = function(settings) {

    /* TAINT use multimix for options handling */
    return Object.assign({}, require('../options'));
  };

  this.$read_package_json = function(S) {
    return $((function(_this) {
      return function(package_path, send) {
        var package_json;
        package_json = require(PATH.resolve(package_path, 'package.json'));
        package_json[σ_module_path] = package_path;
        return send(package_json);
      };
    })(this));
  };

  this.$compile_nfo = function(S) {

    /* `nfo`: package info object */
    return $((function(_this) {
      return function(package_json, send) {
        var Z, key, ref, ref1, value;
        Z = {};
        Z['path'] = package_json[σ_module_path];
        Z['name'] = package_json['name'];
        Z['local-version'] = package_json['version'];
        Z['dependencies'] = package_json['dependencies'];
        ref1 = (ref = package_json['devDependencies']) != null ? ref : {};
        for (key in ref1) {
          value = ref1[key];
          Z['dependencies'][key] = value;
        }
        return send(Z);
      };
    })(this));
  };

  this.$read_npm = function(S) {
    return $async((function(_this) {
      return function(nfo, send, end) {
        var package_name, url;
        if (nfo != null) {
          package_name = nfo['name'];
          url = "http://registry.npmjs.org/" + package_name;
          step(function*(resume) {
            var npm_info, ref, ref1, ref2;
            npm_info = (yield _this._request(url, resume));
            nfo['npm-latest-version'] = (ref = (ref1 = npm_info['dist-tags']) != null ? ref1['latest'] : void 0) != null ? ref : null;
            nfo['npm-all-versions'] = Object.keys((ref2 = npm_info['versions']) != null ? ref2 : {});
            return send.done(nfo);
          });
        }
        if (end != null) {
          return end();
        }
      };
    })(this));
  };

  this.$as_table = function(S) {
    var $cast, $colorize, $show, table_settings;
    table_settings = {
      headings: ['name', 'local', 'npm'],
      alignment: 'left',
      widths: [30, 12]
    };
    $cast = (function(_this) {
      return function() {
        return $(function(nfo, send) {
          var i, len, local_version, local_version_is_published, name, name_display, npm_version, npm_versions, ref, results, version;
          local_version = nfo['local-version'];
          local_version_is_published = false;
          if ((npm_versions = nfo['npm-all-versions']) != null) {
            name_display = nfo['name'];
            for (i = 0, len = npm_versions.length; i < len; i++) {
              npm_version = npm_versions[i];
              if (local_version === npm_version) {
                local_version_is_published = true;
                send([name_display, local_version, npm_version]);
              } else {
                send([name_display, '— ··· —', npm_version]);
              }
              name_display = '  — ··· —';
            }
            if (!local_version_is_published) {
              send([name_display, local_version, '-/-']);
            }
          } else {
            send([nfo['name'], local_version, '-/-']);
          }
          ref = nfo['dependencies'];
          results = [];
          for (name in ref) {
            version = ref[name];

            /* TAINT */
            results.push(send([name, version, '']));
          }
          return results;
        });
      };
    })(this);
    $colorize = (function(_this) {
      return function() {
        return $(function(row, send) {
          return send(row);
        });
      };
    })(this);
    $show = (function(_this) {
      return function() {
        return $(function(row) {
          return echo(row);
        });
      };
    })(this);
    return D.new_stream({
      pipeline: [$cast(), $colorize(), D.$tabulate(table_settings), $show()]
    });
  };

  this.f = function(handler) {
    var S, i, input, len, package_path, package_paths;
    S = this._new_state();
    input = D.new_stream();
    input.pipe(this.$read_package_json(S)).pipe(this.$compile_nfo(S)).pipe(this.$read_npm(S)).pipe(this.$as_table(S)).pipe($('finish', function() {
      return handler();
    }));
    package_paths = ['/home/flow/io/guy-test', '/home/flow/io/ncr', '/home/flow/io/cnd', '/home/flow/io/mingkwai-ncr', '/home/flow/io/interskiplist'];
    for (i = 0, len = package_paths.length; i < len; i++) {
      package_path = package_paths[i];
      D.send(input, package_path);
    }
    D.end(input);
    return null;
  };

}).call(this);

//# sourceMappingURL=main.js.map
