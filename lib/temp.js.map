{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/temp.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n############################################################################################################\nH                         = require './_helpers'\ndebug                     = console.log\ndefaults                  = { keep: false, prefix: 'guy.temp-', suffix: '', }\n\n\n#-----------------------------------------------------------------------------------------------------------\n@with_file = ( cfg, handler ) ->\n  switch arity = arguments.length\n    when 1 then [ cfg, handler, ] = [ null, cfg, ]\n    when 2 then null\n    else throw new Error \"expected 1 or 2 arguments, got #{arity}\"\n  cfg   = { defaults..., cfg..., }\n  type  = Object::toString.call handler\n  return @_with_file_async cfg, handler if type is '[object AsyncFunction]'\n  return @_with_file_sync  cfg, handler if type is '[object Function]'\n  throw new Error \"^guy.temp@1^ expected an (sync or async) function, got a #{type}\"\n\n#-----------------------------------------------------------------------------------------------------------\n@with_directory = ( cfg, handler ) ->\n  switch arity = arguments.length\n    when 1 then [ cfg, handler, ] = [ null, cfg, ]\n    when 2 then null\n    else throw new Error \"expected 1 or 2 arguments, got #{arity}\"\n  cfg   = { defaults..., cfg..., }\n  type  = Object::toString.call handler\n  return @_with_directory_async cfg, handler if type is '[object AsyncFunction]'\n  return @_with_directory_sync  cfg, handler if type is '[object Function]'\n  throw new Error \"^guy.temp@2^ expected an (sync or async) function, got a #{type}\"\n\n#-----------------------------------------------------------------------------------------------------------\n@_with_file_sync = ( cfg, handler ) ->\n  TEMP          = require 'tmp'\n  { name: path\n    fd\n    removeCallback } = TEMP.fileSync cfg\n  try handler { path, fd, } finally\n    removeCallback() unless cfg.keep\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@_with_directory_sync = ( cfg, handler ) ->\n  FS              = require 'node:fs'\n  TEMP            = require 'tmp'\n  { name: path, } = TEMP.dirSync cfg\n  try handler { path, } finally\n    FS.rmSync path, { recursive: true, } unless cfg.keep\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@_with_file_async = ( cfg, handler ) ->\n  TEMP          = require 'tmp'\n  { name: path\n    fd\n    removeCallback } = TEMP.fileSync cfg\n  try await handler { path, fd, } finally\n    removeCallback() unless cfg.keep\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@_with_directory_async = ( cfg, handler ) ->\n  switch arity = arguments.length\n    when 1 then [ cfg, handler, ] = [ null, cfg, ]\n    when 2 then null\n    else throw new Error \"expected 1 or 2 arguments, got #{arity}\"\n  cfg             = { defaults..., cfg..., }\n  FS              = require 'node:fs'\n  TEMP            = require 'tmp'\n  { name: path, } = TEMP.dirSync cfg\n  try await handler { path, } finally\n    FS.rmSync path, { recursive: true, } unless cfg.keep\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@with_shadow_file = ( original_path, handler ) ->\n  if ( type = Object::toString.call original_path ) is '[object Object]'\n    cfg = { path: null, all: false, original_path..., }\n    return @_with_shadow_file cfg.path, cfg.all, handler\n  return @_with_shadow_file original_path, false, handler\n\n#-----------------------------------------------------------------------------------------------------------\n@_with_shadow_file = ( original_path, all, handler ) ->\n  type  = Object::toString.call handler\n  return @_with_shadow_file_async original_path, all, handler if type is '[object AsyncFunction]'\n  return @_with_shadow_file_sync  original_path, all, handler if type is '[object Function]'\n  throw new Error \"^guy.temp@3^ expected an (sync or async) function, got a #{type}\"\n\n#-----------------------------------------------------------------------------------------------------------\n@_with_shadow_file_sync = ( original_path, all, handler ) ->\n  ### TAINT check that original_path is nonexistent or file path, not directory ###\n  GFS       = require './fs'\n  FS        = require 'node:fs'\n  PATH      = require 'node:path'\n  real_path = FS.realpathSync original_path\n  @with_directory ({ path: folder_path, }) ->\n    base_name = PATH.basename real_path\n    temp_path = PATH.join folder_path, base_name\n    FS.copyFileSync real_path, temp_path\n    handler { path: temp_path, }\n    if all\n      real_folder_path = PATH.dirname real_path\n      for filename in FS.readdirSync folder_path\n        source_path = PATH.join folder_path, filename\n        target_path = PATH.join real_folder_path, filename\n        continue unless ( FS.lstatSync source_path ).isFile()\n        GFS.rename_sync source_path, target_path\n    else\n      GFS.rename_sync temp_path, real_path\n  return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @with_shadow_files = ( original_paths..., handler ) ->\n#   unless ( arity = arguments.length ) > 1\n#     throw new Error \"^guy.temp@1^ expected 2 or more arguments, got #{arity}\"\n#   type = Object::toString.call handler\n#   return @_with_shadow_files_async original_paths, handler if type is '[object AsyncFunction]'\n#   return @_with_shadow_files_sync  original_paths, handler if type is '[object Function]'\n#   throw new Error \"^guy.temp@3^ expected an (sync or async) function, got a #{type}\"\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_with_shadow_files_sync = ( original_paths, handler ) ->\n#   ### TAINT check that original_path is nonexistent or file path, not directory ###\n#   GFS           = require './fs'\n#   FS            = require 'node:fs'\n#   PATH          = require 'node:path'\n#   paths         = []\n#   real_paths    = original_paths # ( FS.realpathSync original_path for original_path in original_paths )\n#   @with_directory ({ path: folder_path, }) ->\n#     temp_paths = []\n#     for real_path in real_paths\n#       base_name = PATH.basename real_path\n#       temp_path = PATH.join folder_path, base_name\n#       FS.copyFileSync real_path, temp_path\n#       temp_paths.push temp_path\n#     handler { paths: temp_paths, }\n#     for temp_path, idx in temp_paths\n#       real_path = real_paths[ idx ]\n#       if safe_is_file FS, temp_path then  GFS.rename_sync temp_path,  real_path\n#       else                                FS.unlinkSync               real_path\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# safe_is_file = ( FS, path ) ->\n#   try return ( FS.lstatSync path ).isFile() catch error\n#     throw error if error.code isnt 'ENOENT'\n#   return false\n\n"
  ]
}